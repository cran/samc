<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Andrew Marx" />

<meta name="date" content="2021-09-01" />

<title>Overview</title>


<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>


<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Overview</h1>
<h4 class="author">Andrew Marx</h4>
<h4 class="date">2021-09-01</h4>



<div id="background" class="section level2">
<h2>Background</h2>
<p>This package provides a series of functions for working with absorbing Markov chains. A Markov chain is a model consisting of multiple states and describes how transitions occur between these states. An absorbing Markov chain is a special kind of Markov chain where every state is a <em>transient state</em> that can eventually reach one or more <em>absorbing states</em>. Absorbing states are a special type of state that cannot be left. Absorbing Markov chains can be represented using a <span class="math inline">\(P\)</span> matrix with the following structure:</p>
<p><span class="math display">\[
P =
\begin{bmatrix}
Q &amp; R \\
0 &amp; I
\end{bmatrix}
\]</span> Where:</p>
<ul>
<li><span class="math inline">\(Q\)</span> is a matrix that describes the probability of transition between different transient states. <span class="math inline">\(Q_{i,j}\)</span> is the probability of transitioning from transient state <span class="math inline">\(i\)</span> to transient state <span class="math inline">\(j\)</span>. When <span class="math inline">\(i=j\)</span>, the transition probability is describing the probability that a transient state stays the same, or doesn’t transition to a different transient state.</li>
<li><span class="math inline">\(R\)</span> is a matrix that describes the probability of transitioning from a transient state to an absorbing state. <span class="math inline">\(R_{i,k}\)</span> is the probability of transitioning from transient state <span class="math inline">\(i\)</span> to absorbing state <span class="math inline">\(k\)</span>.</li>
<li><span class="math inline">\(0\)</span> is a matrix filled with zeros. The rows correspond to absorbing state <span class="math inline">\(k\)</span>, and the columns correspond to transient states <span class="math inline">\(j\)</span>. This represents that an absorbing state has a 0% probability of transitioning to a transient state</li>
<li><span class="math inline">\(I\)</span> is an identity matrix where each row and column corresponds to the different absorbing states. The main diagonal is filled with ones, and everything else is set to zero. This matrix represents that absorbing state <span class="math inline">\(k\)</span> has a 100% probability of transitioning to itself (i.e., the state will never change).</li>
<li>When combined together, <span class="math inline">\(\begin{bmatrix}0 &amp; I\end{bmatrix}\)</span> represents that once an absorbing state has been entered, it cannot be left for a transient state or a different absorbing state.</li>
</ul>
</div>
<div id="the-samc-class" class="section level2">
<h2>The <code>samc-class</code></h2>
<p>The <code>samc-class</code> is used to manage the <span class="math inline">\(P\)</span> matrix and other information to help ensure that the calculations used by the rest of the package are used correctly. Creating an <code>samc-class</code> object is the mandatory first step in the package, and is created using the <code>samc()</code> utility function. When creating the <span class="math inline">\(P\)</span> matrix, <code>samc()</code> only treats the <span class="math inline">\(R\)</span> matrix portion as a single column containing the total absorption probability for each transient state. The <code>samc()</code> function has several parameters that provide a number of different options for constructing the <span class="math inline">\(P\)</span> matrix that is at the core of the <code>samc-class</code>.</p>
<div id="option-1-maps" class="section level4">
<h4>Option 1: Maps</h4>
<p>The first option is using a map of resistance (or conductance) and a map of total absorption with a list of transition arguments to calculate the transition probabilities between cells in the maps. There are certain requirements for these maps:</p>
<ul>
<li>They must be 2-dimensional matrices or <code>RasterLayer</code> objects. They have to be the same type.</li>
<li>They must have the same dimensions (number of rows and columns).</li>
<li><code>NA</code>s are allowed in the cells, but must match between the sets of data. I.e., if cell <code>[3, 6]</code> of the <em>resistance</em> data has a <code>NA</code> value, then cell <code>[3, 6]</code> of the <em>absorption</em> data must also have a <code>NA</code> value, and vice versa.</li>
</ul>
<p>If using <code>RasterLayer</code> objects, then additional conditions must be met:</p>
<ul>
<li>Both sets of data must have the same coordinate extents.</li>
<li>Both sets of data must use the same coordinate reference system (CRS).</li>
</ul>
<p>An optional fidelity map may be provided. This map would represent the probability of no transition between timesteps (e.g., no movement). By default, the package treats all cells in the maps the same and uses a value of <code>0</code> for fidelity. If used, the fidelity map must meet all of the same requirements listed above for the other map inputs.</p>
</div>
<div id="option-2-transitionlayer" class="section level4">
<h4>Option 2: TransitionLayer</h4>
<p>A <code>TransitionLayer</code> object can be manually created using the gdistance package and can be further modified before being supplied as an input to <code>samc()</code>, allowing for additional flexibility in constructing the <span class="math inline">\(P\)</span> matrix. While the package is able to check for some potential issues in the <code>TranstionLayer</code>, it is still possible to accidentally modify the <code>TransitionLayer</code> in a way that causes issues that cannot be detected by the package, so extra care must be taken by the user.</p>
<p>This option requires a <code>RasterLayer</code> map of total absorption. This map must match the <code>RasterLayer</code> that was used to create the <code>TransitionLayer</code> using the same conditions as <em>Option 1</em> (above).</p>
<p>This option also allows the input of a <code>RasterLayer</code> fidelity map with the same requirements as <em>Option 1</em> (above).</p>
</div>
<div id="option-3-p-matrix" class="section level4">
<h4>Option 3: P Matrix</h4>
<p>The Third option for using this package is to directly supply a <span class="math inline">\(P\)</span> matrix. The <span class="math inline">\(P\)</span> matrix can be provided either as a regular matrix or a <code>dgCmatrix</code>, which is a sparse matrix object available through the Matrix package. The <span class="math inline">\(R\)</span> portion of the <span class="math inline">\(P\)</span> matrix must be a single column which represents the total absorption probability for each transient state.</p>
<p>The advantage of this approach is total flexibility. The disadvantage is that the <span class="math inline">\(P\)</span> matrix can be created with certain properties that would lead to crashes, and the package is unable to detect all of them at this time. The other disadvantage is that the package cannot map the results back to anything for visualization purposes.</p>
</div>
<div id="option-4-igraph" class="section level4">
<h4>Option 4: igraph</h4>
<p>A future version of the package will incorporate igraph support for graph based inputs. This will provide the flexibility of a custom <span class="math inline">\(P\)</span> matrix, but will generally be more user-friendly to construct, be able to perform more thorough data checking to avoid issues in the <span class="math inline">\(P\)</span> matrix, and allow for mapping the results back to a graph for visualization purposes.</p>
</div>
</div>
<div id="utility-functions" class="section level2">
<h2>Utility Functions</h2>
<p>In addition to the <code>samc()</code> function, the package has other utility functions that users might find helpful:</p>
<ul>
<li>The <code>check()</code> function is used to check that input map data meets the data requirements outlined above. It can be used to compare two <code>RasterLayer</code> objects, two <code>matrix</code> objects, or check either a <code>RasterLayer</code> or a <code>matrix</code> against an already created <code>samc-class</code> object. It can also be used with a <code>RasterStack</code> to check all the layers in the stack against one another.</li>
<li>The <code>map()</code> function is used to simplify mapping vector results based on input maps and returns a <code>RasterLayer</code>. This is provided because R handles matrices and raster layers somewhat differently when reading and writing vector data, which can cause users to map the data incorrectly if they aren’t careful. It also handles mapping with NA values, another potential source of error.</li>
<li>The <code>locate()</code> function is used to get cell numbers for use as <code>origin</code> and <code>dest</code> values in various analytical function arguments. This function should be used instead of <code>cellFromXY()</code> in the raster package because <code>cellFromXY()</code> cell numbers do not necessarily correspond to cell numbers in the samc package (the samc package does not assign cell numbers to <code>NA</code> cells, whereas the raster package does). The <code>locate()</code> function can be used to return a <code>RasterLayer</code> with the cell numbers encoded as cell values by simply excluding the <code>xy</code> argument.</li>
<li>The <code>pairwise()</code> function is provided to easily and efficiently run specific metrics for all the pairwise combinations of start and end locations.</li>
</ul>
</div>
<div id="analytical-functions" class="section level2">
<h2>Analytical Functions</h2>
<p>The package implements functions for the formulas provided in Table 1 of Fletcher et al. (<a href="https://onlinelibrary.wiley.com/doi/full/10.1111/ele.13333">2019</a>), as well as other new ones since that publication. Many of the formulas are related conceptually, and are grouped together into single functions with multiple parameter signatures to reduce the number of unique function names needed. Note that the descriptions assume <span class="math inline">\(\psi\)</span> contains probabilities (see above). The following descriptions were written in an ecological context; the function reference pages provide mathematically formal descriptions.</p>
<table>
<colgroup>
<col width="30%"></col>
<col width="30%"></col>
<col width="39%"></col>
</colgroup>
<thead>
<tr class="header">
<th align="left">Function</th>
<th align="left">Equation</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>absorption()</code></td>
<td align="left"><span class="math inline">\(A = F R\)</span></td>
<td align="left">Probability of an individual experiencing a specific type of mortality</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"><span class="math inline">\(\psi^T A\)</span></td>
<td align="left">Probability of an individual experiencing a specific type of mortality, regardless of initial location</td>
</tr>
<tr class="odd">
<td align="left"><code>cond_passage()</code></td>
<td align="left"><span class="math inline">\(\tilde{t} = \tilde{B}_j^{-1}\tilde{F}\tilde{B}_j{\cdot}1\)</span></td>
<td align="left">Mean first conditional passage time</td>
</tr>
<tr class="even">
<td align="left"><code>dispersal()</code></td>
<td align="left"><span class="math inline">\(\tilde{D}_{jt}=({\sum}_{n=0}^{t-1}\tilde{Q}^n)\tilde{q}_j\)</span></td>
<td align="left">Probability of an individual visiting a location, if starting at any other location, before or at time <em>t</em></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><span class="math inline">\(\psi^T\tilde{D}_{jt}\)</span></td>
<td align="left">Probability of an individual visiting a location, before or at time <em>t</em>, regardless of initial location</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"><span class="math inline">\(D=(F-I)diag(F)^{-1}\)</span></td>
<td align="left">Probability of an individual visiting a location</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><span class="math inline">\(\psi^TD\)</span></td>
<td align="left">Probability of an individual visiting a location, regardless of initial location</td>
</tr>
<tr class="even">
<td align="left"><code>distribution()</code></td>
<td align="left"><span class="math inline">\(Q^t\)</span></td>
<td align="left">Probability of an individual being at a location at time <em>t</em></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><span class="math inline">\(\psi^TQ^t\)</span></td>
<td align="left">Probability of an individual being at a location at time <em>t</em>, regardless of initial location</td>
</tr>
<tr class="even">
<td align="left"><code>mortality()</code></td>
<td align="left"><span class="math inline">\(\tilde{B}_t = (\sum_{n=0}^{t-1} Q^n) \tilde{R}\)</span></td>
<td align="left">Probability of an individual experiencing mortality at a location before or at time <em>t</em></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><span class="math inline">\(\psi^T \tilde{B}_t\)</span></td>
<td align="left">Probability of an individual experiencing mortality at a location, before or at time <em>t</em>, regardless of initial location</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"><span class="math inline">\(B = F \tilde{R}\)</span></td>
<td align="left">Probability of an individual experiencing mortality at a location</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><span class="math inline">\(\psi^T B\)</span></td>
<td align="left">Probability of an individual experiencing mortality at a location, regardless of initial location</td>
</tr>
<tr class="even">
<td align="left"><code>survival()</code></td>
<td align="left"><span class="math inline">\(z=(I-Q)^{-1}{\cdot}1=F{\cdot}1\)</span></td>
<td align="left">Expected life expectancy of an individual</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"><span class="math inline">\({\psi}^Tz\)</span></td>
<td align="left">Overall life expectancy, regardless of initial location</td>
</tr>
<tr class="even">
<td align="left"><code>visitation()</code></td>
<td align="left"><span class="math inline">\(F = (I-Q)^{-1}\)</span></td>
<td align="left">Expected number of times an individual visits a location</td>
</tr>
</tbody>
</table>
<p>Depending on the combination of inputs used, a function might return a single value, a vector, a matrix, or a list. In some cases, the calculations will be impractical with sufficiently large landscape datasets due to memory and other performance constraints. To work around this, many equations have multiple associated function signatures that allow users to calculate individual portions of the result rather than the entire result. This opens up multiple optimizations that makes calculating many of the metrics more practical. More specific details about performance considerations can be found in the <a href="performance.html">Performance</a> vignette.</p>
<div id="initial-state-data" class="section level4">
<h4>Initial State Data</h4>
<p>Several of the analytical functions allow the input of an initial state <span class="math inline">\(\psi\)</span> for the Markov chain via the <code>occ</code> parameter. The descriptions for these analytical functions assume that values in <span class="math inline">\(\psi\)</span> sum to one. When this is the case, <span class="math inline">\(\psi_i\)</span> represents the probability that the Markov chain starts in transient state <span class="math inline">\(i\)</span>.</p>
<p>When the values in <span class="math inline">\(\psi\)</span> sum to a value other than one, care must be taken in the interpretation of the results. For example, <span class="math inline">\(\psi\)</span> could be used to represent a population of individuals where <span class="math inline">\(\psi_i\)</span> represents the number of individuals that start in transient state <span class="math inline">\(i\)</span>. In this case, the results of the functions using <span class="math inline">\(\psi\)</span> aren’t probabilities, but rather the expected number of individuals.</p>
</div>
</div>
<div id="built-in-example-data" class="section level2">
<h2>Built-in Example Data</h2>
<p>The package includes built-in example map data. Some of this data was used to create the figures in the SAMC paper, and is used in numerous package tutorials. They are:</p>
<ul>
<li><code>ex_res_data</code>: A matrix with landscape resistance data.</li>
<li><code>ex_abs_data</code>: A matrix with landscape absorption (mortality) data.</li>
<li><code>ex_occ_data</code>: A matrix with landscape occupancy data.</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">str</span>(samc<span class="op">::</span>ex_res_data)</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">str</span>(samc<span class="op">::</span>ex_abs_data)</a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">str</span>(samc<span class="op">::</span>ex_occ_data)</a>
<a class="sourceLine" id="cb1-4" title="4"></a>
<a class="sourceLine" id="cb1-5" title="5"></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="kw">plot</span>(<span class="kw">raster</span>(samc<span class="op">::</span>ex_res_data, <span class="dt">xmn =</span> <span class="dv">1</span>, <span class="dt">xmx =</span> <span class="kw">ncol</span>(samc<span class="op">::</span>ex_res_data), <span class="dt">ymn =</span> <span class="dv">1</span>, <span class="dt">ymx =</span> <span class="kw">nrow</span>(samc<span class="op">::</span>ex_res_data)),</a>
<a class="sourceLine" id="cb1-7" title="7">     <span class="dt">main =</span> <span class="st">&quot;Example Resistance Data&quot;</span>, <span class="dt">xlab =</span> <span class="st">&quot;x&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;y&quot;</span>, <span class="dt">col =</span> <span class="kw">viridis</span>(<span class="dv">256</span>))</a>
<a class="sourceLine" id="cb1-8" title="8"></a>
<a class="sourceLine" id="cb1-9" title="9"><span class="kw">plot</span>(<span class="kw">raster</span>(samc<span class="op">::</span>ex_abs_data, <span class="dt">xmn =</span> <span class="dv">1</span>, <span class="dt">xmx =</span> <span class="kw">ncol</span>(samc<span class="op">::</span>ex_abs_data), <span class="dt">ymn =</span> <span class="dv">1</span>, <span class="dt">ymx =</span> <span class="kw">nrow</span>(samc<span class="op">::</span>ex_abs_data)),</a>
<a class="sourceLine" id="cb1-10" title="10">     <span class="dt">main =</span> <span class="st">&quot;Example Absorption Data&quot;</span>, <span class="dt">xlab =</span> <span class="st">&quot;x&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;y&quot;</span>, <span class="dt">col =</span> <span class="kw">viridis</span>(<span class="dv">256</span>))</a>
<a class="sourceLine" id="cb1-11" title="11"></a>
<a class="sourceLine" id="cb1-12" title="12"><span class="kw">plot</span>(<span class="kw">raster</span>(samc<span class="op">::</span>ex_occ_data, <span class="dt">xmn =</span> <span class="dv">1</span>, <span class="dt">xmx =</span> <span class="kw">ncol</span>(samc<span class="op">::</span>ex_occ_data), <span class="dt">ymn =</span> <span class="dv">1</span>, <span class="dt">ymx =</span> <span class="kw">nrow</span>(samc<span class="op">::</span>ex_occ_data)),</a>
<a class="sourceLine" id="cb1-13" title="13">     <span class="dt">main =</span> <span class="st">&quot;Example Occupancy Data&quot;</span>, <span class="dt">xlab =</span> <span class="st">&quot;x&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;y&quot;</span>, <span class="dt">col =</span> <span class="kw">viridis</span>(<span class="dv">256</span>))</a></code></pre></div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
